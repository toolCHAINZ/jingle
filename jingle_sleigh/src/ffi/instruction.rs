use crate::ffi::instruction::bridge::Disassembly;
use std::fmt::{Display, Formatter};

impl Display for Disassembly {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{} {}", self.mnemonic, self.args)
    }
}

#[cxx::bridge]
pub(crate) mod bridge {
    /// An FFI-friendly representation of a [`VarNode`](crate::VarNode)
    pub(crate) struct VarnodeInfoFFI {
        space: SharedPtr<AddrSpaceHandle>,
        offset: u64,
        size: usize,
    }

    /// An FFI-friendly representation of the association between [`VarNode`](crate::VarNode)
    /// and an architectural register name. This is used for pretty-printing register accesses
    /// and allows referring to registers by name.
    pub(crate) struct RegisterInfoFFI {
        varnode: VarnodeInfoFFI,
        name: String,
    }

    /// An FFI-friendly representation of a single [`PCodeOperation`](crate::PcodeOperation).
    pub(crate) struct RawPcodeOp {
        op: OpCode,
        inputs: Vec<VarnodeInfoFFI>,
        output: VarnodeInfoFFI,
        has_output: bool,
        space: SharedPtr<AddrSpaceHandle>,
    }

    /// A display-friendly representation of an instruction, generated by SLEIGH. Sleigh does not
    /// provide any tokenization of instruction operands, so they are all contained as a string
    /// representation in the [args](Self::args) attribute.
    #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
    pub struct Disassembly {
        /// SLEIGH's name for an ISA instruction
        pub mnemonic: String,
        /// A combined string representation of all the arguments of the instruction.
        pub args: String,
    }

    /// An FFI-friendly representation of a single [`Instruction`](crate::Instruction)
    pub(crate) struct InstructionFFI {
        disassembly: Disassembly,
        address: u64,
        ops: Vec<RawPcodeOp>,
        length: usize,
    }

    unsafe extern "C++" {
        include!("jingle_sleigh/src/ffi/cpp/sleigh/opcodes.hh");
        include!("jingle_sleigh/src/ffi/cpp/addrspace_handle.h");
        #[namespace = "ghidra"]
        type OpCode = crate::ffi::opcode::OpCode;

        type AddrSpaceHandle = crate::ffi::addrspace::bridge::AddrSpaceHandle;
    }
}
